<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>TypeScript</title>

		<meta name="Presentation on TypeScript">
		<meta name="author" content="Froilan Miranda">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<div class="slides">

			<!------------------------------------slide--------------------------------------------- -->
				<section>
					<h1>TypeScript</h1>
					<h3>An Introduction</h3>
					<p>
						<small>Created by <a href="http://www.zipcoder.io">Froilan Miranda</a></small>
					</p>
				</section>

			<!------------------------------------slide--------------------------------------------- -->
				<section>
					<section>
						<h2>Introduction</h2>
					</section>
					<section>
						<h2>TypeScript vs. JavaScript</h2>
						<p>
							<ul>
								<li>TypeScript starts from the same syntax and semantics that millions of JavaScript developers know today. Use existing JavaScript code, incorporate popular JavaScript libraries, and call TypeScript code from JavaScript.</li>
								<li>TypeScript compiles to clean, simple JavaScript code which runs on any browser, in Node.js, or in any JavaScript engine that supports ECMAScript 3 (or newer).</li>
							</ul>
						</p>
					</section>
					<section>
						<h2>What Is TypeScript?</h2>
						<p>
							<ul>
								<li>Open source </li>
								<li>Maintained by Microsoft</li>
								<li>Translates to a configurable JavaScript version</li>
								<li>Uses ES6/ES7 syntax if possible</li>
								<li>Adds typing</li>
							</ul>
						</p>
					</section>
					<section>
						<h2>The Transpiler</h2>
					</section>
					<section>
						<h2>The Editor</h2>
					</section>
					<section>
						<h2>Transpiling the code</h2>
					</section>
					<section>
						<h2>Tsconfig.json and tsc Command Line Arguments</h2>
					</section>
					<section>
						<h2>Source Maps</h2>
						<p>
							Source maps help with debugging as they point the TS code instead of the transpiled JS
						</p>
					</section>
					<section>
						<h2>Bootstrapping an Application</h2>
						<p>
							This becomes the entry point for our application
						</p>
					</section>
					<section>
						<h2>Debugging</h2>
						<p>
							We can use the browsers development tools to help find errors in our code
						</p>
					</section>
					<section>
						<h2>Referencing Other TypeScript Files</h2>
						<p>
							We can use references to specify what typescript files need to be loaded and what order
						</p>
					</section>
				</section>

				<!------------------------------------slide--------------------------------------------- -->
				<section>
					<section>
						<h2>Understanding the Language Basics</h2>
					</section>
					<section>
						<h2>Classes and Objects</h2>
						<ul>
							<li>A Class is a blue print</li>
							<li>Class contain fields</li>
							<li>Classes alse contain functions or methods</li>
						</ul>
					</section>
					<section>
						<h2>Data Types</h2>
						<ul>
							<li>Built-in
								<ul>
									<li>Boolean</li>
									<li>String</li>
									<li>Number</li>
								</ul>
							</li>
							<li>Custom
								<ul>
									<li>Enum</li>
									<li>Array</li>
									<li>Interface</li>
									<li>Class</li>
								</ul>
							</li>
							<li>any</li>
						</ul>
					</section>
					<section>
						<h2>Implementing a Class</h2>
					</section>
					<section>
						<h2>Type Inference</h2>
						<p>
							In TypeScript, there are several places where type inference is used to provide type information when there is no explicit type annotation.
						</p>
					</section>
					<section>
						<h2>Access Modifiers</h2>
						<p>
							TypeScript supports the common access modifiers that control class members access
						</p>
						<p>
							Typescript access modifiers are
							<ul>
								<li>public : available on instances everywhere</li>
								<li>private : not available for access outside the class.</li>
								<li>protected : available on child classes but not on instances directly</li>
							</ul>
						</p>
					</section>
					<section>
						<h2>Properties</h2>
						<p>
							We use getters and setters to gain access to class properties
						</p>
					</section>
					<section>
						<h2>Functions and Arrows</h2>
					</section>
					<section>
						<h2>Connection the UI</h2>
					</section>
					<section>
						<h2>Connecting the UI with Knockout.js</h2>
						<ul>
							<li>Use data binding</li>
							<li>Knockout.js</li>
							<li>There are other solutions</li>
						</ul>
					</section>
					<section>
						<h2>Type Definitions</h2>
						<ul>
							<li>TypeScript contains typing for standard javascript objects</li>
							<li>But it doesn’t know about external libraries</li>
							<li>Type definitions help out</li>
							<li>(link to type.org) </li>
						</ul>
					</section>
					<section>
						<h2>Refactoring the UI Logic</h2>
					</section>
					<section>
						<h2>let</h2>
						<ul>
							<li>var Variables in JavaScript are function scoped</li>
							<li>When a variable is declared using let, it uses what some call lexical-scoping or block-scoping.</li>
						</ul>
					</section>
					<section>
						<h2>Arrays</h2>
						<p>
							Array types can be written in one of two ways
						</p>
						<ul>
							<li>you use the type of the elements followed by [] to denote an array of that element type</li>
							<li>The second way uses a generic array type, Array<elemType></li>
						</ul>
					</section>
					<section>
						<h2>Constructors</h2>
						<ul>
							<li>Responsible for allocating memory for the objects of the class</li>
							<li>The class does not need to have a constructor.</li>
						</ul>
					</section>
					<section>
						<h2>Static Members</h2>
						<ul>
							<li>A field, property or method, or otherwise a member on the class level</li>
							<li>When you define something as static it is available on the class level, it won't be available on the object level</li>
						</ul>
					</section>
					<section>
						<h2>Enums</h2>
						<ul>
							<li>Constraint</li>
							<li>Maintainability of Code</li>
							<li>Readability of Code</li>
						</ul>
					</section>
					<section>
						<h2>Loops</h2>
						<p>
							Ko.js allows to quickly create UI elements with loops
						</p>
					</section>
				</section>

				<!------------------------------------slide--------------------------------------------- -->
				<section>
					<section>
						<h2>Apply Object Orientation</h2>
					</section>
					<section>
						<h2>The Problem Polymorphism Solves</h2>
						<p>
							Polymorphism in its pure definition means to have many shapes.
						</p>
					</section>
					<section>
						<h2>Inheritance</h2>
						<p>
							Inheritance means that when a class of objects is defined, any subclass or derived class that is defined can inherit the definitions of one or more general classes
						</p>
					</section>
					<section>
						<h2>Polymorphism Implemented</h2>
					</section>
					<section>
						<h2>Abstract Classes</h2>
						<p>
							Abstract classes are base classes from which other classes may be derived. They may not be instantiated directly.
						</p>
					</section>
					<section>
						<h2>Super</h2>
						<p>
							The super keyword can be used in expressions to reference base class properties and the base class constructor.
						</p>
					</section>
					<section>
						<h2>Protected</h2>
						<ul>
							<li>For encapsulation</li>
							<li>Hide complexity</li>
							<li>Maintainable code</li>
							<li>Hide as much as possible</li>
							<li>Low coupling</li>
						</ul>
					</section>
					<section>
						<h2>Using Protected Members</h2>
					</section>
					<section>
						<h2>Interfaces</h2>
						<ul>
							<li>Separate Types</li>
							<li>Can’t contain implementaion</li>
							<li>Act as a contract for a class</li>
							<li>A class can implement multiple</li>
							<li>Can be used with unrelated classes</li>
						</ul>
					</section>
				</section>

				<!------------------------------------slide--------------------------------------------- -->
				<section>
					<section>
						<h2>Structuring Code</h2>
					</section>
					<section>
						<h2>The Global Namespace</h2>
						<p>
							Every time you declare a class in typescript it is added to the global namespace
						</p>
						<p>
							Grouping classes
							<ul>
								<li>Less chance of naming conflicts</li>
								<li>Added semantics</li>
								<li>Extra level of encapsulation</li>
							</ul>
						</p>
					</section>
					<section>
						<h2>Namespaces</h2>
						<p>
							As we add more validators, we’re going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects
						</p>
					</section>
					<section>
						<h2>Modules</h2>
						<ul>
							<li>Way to group code</li>
							<li>The file is the container</li>
							<li>Other files have to import</li>
							<li>No reference paths needed</li>
							<li>All or nothing</li>
						</ul>
					</section>
					<section>
						<h2>Applying Modules</h2>
					</section>
					<section>
						<h2>Generics</h2>
						<p>
							In languages like C# and Java, one of the main tools in the toolbox for creating reusable components is generics, that is, being able to create a component that can work over a variety of types rather than a single one
						</p>
					</section>
					<section>
						<h2>Applying Generics</h2>
					</section>
					<section>
						<h2>Generic Constraints</h2>
						<p>
							you may sometimes want to write a generic function that works on a set of types where you have some knowledge about what capabilities that set of types will have
						</p>
					</section>
					<section>
						<h2>Decorators</h2>
						<ul>
							<li>Experimental</li>
							<li>Angular 2</li>
							<li>Functions</li>
							<li>Classes, methods, properties or parameters</li>
							<li>Reusable</li>
						</ul>
					</section>
				</section>
			</div><!-- slides -->
		</div><!-- reveal -->

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
